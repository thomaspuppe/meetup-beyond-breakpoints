<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CSS Beyond Breakpoints</title>
    <link rel="stylesheet" href="vendor/prism/prism.min.css">
    <link rel="stylesheet" href="style.css">
</head>
<body>

    <div class="slide-container">

        <!-- ===============================================================
         +++ +++ +++ +++ Real Content Starts Here. +++ +++ +++ +++ +++
         =============================================================== -->

        <div class="slide" data-slide-type="title" data-title="Willkommen">
            <h1>CSS Beyond Breakpoints</h1>
            <p class="subtitle">Design und Layout ohne Breakpoints, daf√ºr mit modernem CSS</p>
            <p style="display:flex; gap:1ch; font-style:italic;align-items: center;justify-content: center;">
                <img height="50" width="50" style="margin-block: 0; border-radius: 50%;" src="images/toy-face.png" alt="">
                Thomas Puppe
            </p>
        </div>
<aside>
Guten Abend. Ich m√∂chte mit euch √ºber CSS sprechen. (Also erstmal zu euch, und dann sehen wir weiter.)
Mein Name ist Thomas Puppe. Ich bin Senior Frontend Developer bei der ZEIT.
</aside>

        <div class="slide" data-slide-type="title" data-title="Willkommen 2">
            <h1>Hi, ich bin Thomas üëã</h1>
                <img src="images/toy-face.png" width="300px"/>
                <h2>								
                    <p>Senior Frontend Developer <br>bei der ZEIT</p>
                    <em>#a11y, #leanweb, #webperf</em>
                </h2>
        </div>

        <aside>
        Ich baue seit einem Vierteljahrhundert Websites. Und meine Steckenpferde sind Accessibility, Performance, und etwas das man "LeanWeb" nennt.
        Die Idee, dass Websites einfach und klein und leicht zu warten sein sollten, 
        Damit passe ich ganz gut zu ZEIT. (Formerly ZEIT Online.)
        </aside>

        <div class="slide" data-slide-type="title" data-title="Willkommen 3">
            <h1>zeit.de</h1>
            <div class="r-hstack" style="gap:5vw">
                <img src="images/zeit_screenshot-1.png" style="width:min(100%, 35vw)"/>
                <img src="images/zeit_screenshot-2.png" style="width:min(100%, 35vw)"/>
            </div>
        </div>

        <aside>
        Wir legen auch wert auf Standardkonformit√§t, Accessibility, Performance. 
        Und auf Wartbarkeit, weil es ist eine gro√üe Codebasis, die wir da seit 10 Jahren betreuen.
        Dazu geh√∂rt: Wenig Frameworks, Viel Vanilla.
        Eher konservativ bzgl Browser-Support; aber wenn etwas unterst√ºtzt wird, dann nutzen wir die verf√ºgbare Technologie im Sinne des Lean Web.
        Also dass man sich lieber auf den Browser verl√§sst, und dessen F√§higkeiten nutzt, anstatt das Rad selber neu zu erfinden.
        </aside>

        <div class="slide" data-slide-type="title" data-title="Willkommen">
            <h1>CSS Beyond Breakpoints</h1>
            <p class="subtitle">Design und Layout ohne Breakpoints, daf√ºr mit modernem CSS.</p>
        </div>

        <aside>
        Und davon handelt mein heutiger Talk. CSS beyond Breakpoints.
        Wie √ºberwinden wir das, was ich vor 15 Jahren gelernt habe im Zuge von Responsive Web Design, Mobile First, viel mit Breakpoints.
        Und welche moderneren Sachen gibt es da?
        Als erstes spreche ich doch noch √ºber Breakpoints, quasi als Hinf√ºhrung. 
        Und dann werden wir die los.
        </aside>

        <!-- --------------------------------------------------------------
         Section: CSS Vars
         -------------------------------------------------------------- -->

        <!-- TODO: data-title nur nutzen, wenn keine h1/h2 verf√ºgbar ist. -->
        <div class="slide" data-slide-type="code" data-title="CSS Vars: Colors">
            <p>CSS Vars: Colors</p>
            <h2>Dark Mode fr√ºher ü¶£</h2>
<pre class="fragment"><code class="language-css">
	body {
		background: white;
		color: black;
	}
	@media (prefers-color-scheme: dark) {
		.body {
			background: black;
			color: white;
		}
	}
</code></pre>
        </div>
        <div class="slide" data-slide-type="code" data-title="CSS Vars: Colors">
            <p>CSS Vars: Colors</p>
            <h2>Dark Mode mit CSS Vars üêò</h2>
<pre><code class="language-css">
:root {
    --z-ds-color-text-100: #252525; // Primary Information
    --z-ds-color-text-70: #444; // Secondary Information
    --z-ds-color-text-40: #999; // Low Prio
    --z-ds-color-background-0: #fff; // Primary
}
:root {
    @media (prefers-color-scheme: dark) {
        --z-ds-color-text-100: #fff;
        --z-ds-color-text-70: #bababa;
        --z-ds-color-text-40: #8b8b8b;
        --z-ds-color-background-0: #121212;
    }
}
body {
    background: var(--z-ds-color-background-0);
    color: var(--z-ds-color-text-100);
}
</code></pre>
        </div>
        <div class="slide" data-slide-type="code" data-title="CSS Vars: Colors">
            <p>CSS Vars: Colors mit CSS Functions</p>
            <h2>Dark Mode mit light-dark() ü¶Ñ</h2>
<pre><code class="language-css">
:root {
    color-scheme: light dark;
    --z-ds-color-text-100: light-dark(#252525, #fff); // Primary Information
    --z-ds-color-text-70: light-dark(#444, #bababa); // Secondary Information
    --z-ds-color-text-40: light-dark(#999, #8b8b8b); // Low Prio
    --z-ds-color-background-0: light-dark(#fff, #121212); // Primary
}
body {
    background: var(--z-ds-color-background-0);
    color: var(--z-ds-color-text-100);
}
</code></pre>
        </div>

        <aside>
        Was sich durch beide Beispiele zieht, sind die CSS Variablen.
        F√ºr ein konsistentes Design und eine wartbare Seite sind die gold wert!
        Ich will auf keinen Fall an irgendwelchen Texten, Teasern, Footerbars, was-auch-immer mit Farbwerten hantieren, sondern mit Variablen. 
        Die sind an einer Stelle definiert ‚Äì damit habe ich auch gleich mein Inventar in Form von Design Tokens ‚Äì und werden dann im Projekt nur noch genutzt.
        Wenn ich die wirklich mal √ºberschreiben will/muss, kann ich das immer noch lokal an meiner Komponente tun.

        So wie ich Farben im CSS als globale Design Tokens definiere, und dann nur noch benutze, so gehe ich auch mit Schriftgr√∂√üen um.
        </aside>

        <div class="slide" data-slide-type="code" data-title="CSS Vars: Font Sizes">
            <h2>CSS Vars: Font Sizes</h2>
<pre><code class="language-css">
--zeit-fontsize-s: 1rem;
--zeit-fontsize-m: 1.25rem;
--zeit-fontsize-l: 1.5rem;

@media (min-width: 600px) {
    --zeit-fontsize-m: 1.5rem;
    --zeit-fontsize-l: 2rem;
}
</code></pre>
<pre class="fragment"><code class="language-css">
.zon-teaser h2 {
    font-size: var(--zeit-fontsize-m);
}

.zon-teaser--large h2 {
    font-size: var(--zeit-fontsize-l);
}
</code></pre>
        </div>

<aside>
Ich hab schonmal den Teil √ºbersprungen, der vorhin als schlechtes Beispiel galt: 
Auf gar keinen Fall will ich innerhalb meines Teaser-Designs mit Breakpoints hantieren.
Ich habe ein Set an Schriftgr√∂√üen, die sind untereinander austariert, und mit denen arbeite ich.
</aside>

        <div class="slide" data-slide-type="image-only" data-title="Inspirational Image">
            <div class="iframe-device">
                <iframe 
                    src="./iframes/font-breakpoint.html" 
                    style="width: 100%; height: 100%; border: none; display: block;">
                </iframe>
            </div>
        </div>

<aside>
Das Ergebnis sehen wir hier. Ganz klassisch. Kleine Schrift, und ab einem Breakpoint wird sie gr√∂√üer.
Das ist ganz cool. Aber: irgendwie unbefriedigend an manchen Stellen. 
Kurz vor dem Breakpoint ist die Schrift etwas verloren. Und kurz danach etwas zu gro√ü vielleicht.
</aside>

        <div class="slide" data-slide-type="headline-images" data-title="Image Grid">
            <h2>Breakpoints f√ºr Font Sizes</h2>
            <div class="image-grid">
                <img src="./images/font_steps.png" alt="" class="fragment">
                <img src="./images/font_multi_steps.png" alt="" class="fragment">
                <img src="./images/font_many_steps.png" alt="" class="fragment">
            </div>
        </div>
<aside>
Jetzt k√∂nnte ich nat√ºrlich in kleineren Schritten vorgehen.
Das wird nat√ºrlich unhandlich. Aber es f√ºhrt uns zu einer spannenden Frage:
</aside>

        <div class="slide" data-slide-type="image-only" data-title="Inspirational Image">
            <img src="./images/question.png" alt="">
        </div>

<aside>
Die Frage lautet: "Was will ich _eigentlich_ erreichen?"
Ich will nicht bei 767 Pixeln Schriftgr√∂√üe 20, und bei 768 Pixelm Schriftgr√∂√üe 30. 
Aber genau das machen wir bei responsivem Web Design mittels Media Queries.
Was ich eigentlich will, ist, dass sich die Schrift dem Bildschirm anpasst. Proportional. Also quasi sowas:
</aside>


        <div class="slide" data-slide-type="headline-images" data-title="Image Grid">
            <h2>Breakpoints f√ºr Font Sizes</h2>
            <div class="image-grid">
                <img src="./images/font_steps.png" alt="">
                <img src="./images/font_multi_steps.png" alt="">
                <img src="./images/font_many_steps.png" alt="">
                <img src="./images/font_clamp.png" alt="">
            </div>
        </div>

<aside>
Und genau das erreichen wir mit bildschirm-relationalen Einheiten, und mit clamp.
</aside>

        <div class="slide" data-slide-type="code-explanation" data-title="Code Explanation: clamp()">
            <h2>CSS `clamp()` ü¶Ñ</h2>
            <pre><code class="no-highlight">font-size: <span data-highlight-id="1">clamp</span>(<span data-highlight-id="3">1.25rem</span>, <span data-highlight-id="2">2vw + 1rem</span>, <span data-highlight-id="4">2.5rem</span>);</code></pre>
            <div class="explanation-container">
                <div class="fragment" data-explains="1">
                    <p><strong>clamp():</strong> Mathematische CSS-Funktion mit sehr gutem Browser-Support.</p>
                </div>
                <div class="fragment" data-explains="2">
                    <p><strong>Bevorzugter Wert:</strong> Idealer Wert der Schriftgr√∂√üe. W√§chst mit dem Bildschirm (2vw) und ber√ºcksichtigt die User-Einstellungen (1rem).</p>
                </div>
                <div class="fragment" data-explains="3">
                    <p><strong>Minimaler Wert:</strong> Untere Grenze. Wird genommen, wenn der ideale Wert drunter f√§llt.</p>
                </div>
                <div class="fragment" data-explains="4">
                    <p><strong>Maximaler Wert:</strong> Obere Grenze. Wird genommen, wenn der ideale Wert gr√∂√üer ist.</p>
                </div>
            </div>
        </div>

<aside>
Das Ergebnis in meinem CSS File f√ºr Design System Tokens ist dann so etwas hier:
</aside>

        <div class="slide" data-slide-type="code" data-title="CSS Vars: Font Sizes">
            <p>CSS Vars: Font Sizes</p>
            <h2>Font Sizes mit `clamp()` ü¶Ñ</h2>
<pre><code class="language-css">
    --zeit-fontsize-2: clamp(1rem, 1.2vw + 0.8rem, 2rem);
    --zeit-fontsize-m: clamp(1.25rem, 2vw + 1rem, 5rem);
    --zeit-fontsize-xl: clamp(2rem, 4vw + 1rem, 6rem);
    
    p {
        font-size: var(--zeit-fontsize-m);
    }
    h1 {
        font-size: var(--zeit-fontsize-xl);
    }
</code></pre>
</div>

<aside>
Und so sieht das aus:
</aside>

        <div class="slide" data-slide-type="image-only" data-title="Inspirational Image">
            <div class="iframe-device">
                <iframe 
                    src="./iframes/font-clamp.html" 
                    style="width: 100%; height: 100%; border: none; display: block;">
                </iframe>
            </div>
        </div>


        <div class="slide" data-slide-type="title" data-title="Willkommen 2">

                <img src="images/utopia.png" width="90%"/>
                <h2>								
                    <a href="https://utopia.fyi">https://utopia.fyi</a>
                </h2>
        </div>

<aside>
Es gibt ein wundersch√∂nen Tool, mit dem ihr euch diese Schriftgr√∂√üen samt Berechnungsfaktoren und Grenzen generieren k√∂nnt.
Ihr gebt eure paar Werte ein, sagt wie viele Schriftgr√∂√üen ihr haben wollt, und er macht die Interpolation.

Apropos Werte und Interpolation ... mit Clamp berechnen wir ja Gr√∂√üen-Einheiten.
Und die kann ich nat√ºrlich nicht nur f√ºr Schriftgr√∂√üen nehmen, sondern auch f√ºr mein Whitespace System.
</aside>

        <div class="slide" data-slide-type="code" data-title="CSS Vars: Spacing">
            <p>CSS Vars: Spacing</p>
            <h2>Spacing mit `clamp()` ü¶Ñ</h2>

            <pre><code class="language-css">
--zeit-space-s: 0.5rem;
--zeit-space-l: clamp(1rem, 1.2vw + 0.8rem, 2rem);;
--zeit-space-xl: clamp(2rem, 4vw + 1rem, 6rem);

h1 {
    margin-block: var(--zeit-space-xl);
}
h2 {
    margin-block: var(--zeit-space-l);
}
p {
    margin-block: var(--zeit-space-s);
}
</code></pre>
</div>

<aside>
Minimalwerte, Skalierung mit Bildschirm, Maximalwerte.
Ich hab jetzt hier nur Text-Elemente und ihr Margin genommen.
Das setzen wir aber nat√ºrlich auch f√ºr Grid-Gaps ein. F√ºr Abst√§nde zwischen Komponenten.
Aber f√ºr das Schriften-Beispiel gilt:
Bei Paragraphs setzen wir das kleinere Spacing ein, bei √úberschriften das gr√∂√üere.
Jetzt kann man sich fragen ... 
</aside>

        <div class="slide" data-slide-type="image-only" data-title="Inspirational Image">
            <img src="./images/question.png" alt="" />
        </div>

<aside>
Was will ich eigentlich?
Ich will nicht 20px unter Abs√§tzen, und 30 Pixel unter √úberschriften. 
Sondern ich will, dass go√üer Text mehr Spacing hat als kleiner Text.
Daf√ºr gibt es schriftrelatve Einheiten in CSS! 
</aside>

        <div class="slide" data-slide-type="code" data-title="CSS Vars: Spacing">
<h2>Spacing mit relativen Einheiten ü¶Ñ</h2>
<pre class="fragment"><code class="language-css">h1, h2 {
    margin-block: 2em;
    margin-block: 2lh;
}</code></pre>

        <!-- Viewport Inline(!), runde auf halbe Zeilenh√∂hen (lokal) -->
    <pre class="fragment"><code class="language-css">h1, h2 {
    margin-inline: min(5ch, 2vi);
    margin-block: round(up, 2vb, 1lh);
}</code></pre>

<pre class="fragment"><code class="language-css">@supports (font-size: 1cqi) {
	font-size: clamp(rem(82px), 8.2cqi, rem(164px));
}</code></pre>

<pre class="fragment"><code class="language-css">p:not([class])  {
    max-width: min(70ch, 100% - 4rem);
}
</code></pre>

</div>

        <aside>
        Min() und Round() sind zwei weitere arithmetische Funktionen in CSS.
        vi und round auf lh sind typische relative Einheiten.
        ch f√ºr character, cap f√ºr Gr√∂√üe des Capital Letters
        .Oder Container Queries. Mach Zeug abh√§ngig von der Gr√∂√üe des Containers.
        Und jetzt kommt ein wichtiger Rat: 
        </aside>

        <div class="slide" data-slide-type="image-only-contain" data-title="Inspirational Image">
            <img src="./images/dinos-discuss.png" alt="" />
        </div>

        <aside>
        Sprecht mal mit euren Designer:innen √ºber solche Regeln. Wenn ihr ganz viel Gl√ºck habt, 
        haben die sich vielleicht was dabei gedacht, als sie die Werte festgelegt haben. 
        Sowas wie ein System. F√ºrs Design.
        Und es k√∂nnte sein, dass die Grundlage f√ºr die Pixelwerte solche √úberlegungen sind.
        Nur dass im Figma eben die Snapshots landen von zwei, drei festen Gr√∂√üen.
        
        Und wir als Entwickler:innen nehmen das als feste Gr√∂√üen pro Breakpoint.
        Weil uns die gemeinsame Sprache fehlt f√ºr die Welt zwischen den Breakpoint-Designs.

        Und dabei geht es nicht darum, die Dinge kompliziert aufzuschreiben mit Container Queries und Character Size Units.
        Sondern darum, sie nur einmal aufzuschreiben. Zum Beispiel den Abstand zwischen Headlines und egal-was-drumherum-ist.
        Und egal, ob es die Headline in der Hero Kachel oder in den AGB ist.
        </aside>

        <div class="slide" data-slide-type="quote" data-title="Andy Bell Quote">
            <blockquote>
                "Be the browser's mentor, <br>not it's micromanager."
            </blockquote>
            <footer>&mdash; Andy Bell</footer>
        </div>

        <aside>
        Es gibt einen sch√∂nen Satz: Be the Browsers Mentor, not it's micromanager.

        Der stammt von Andy Bell ‚Äì Das ist nicht der gleichnamige S√§nger von der Band Erasure. 
        Sondern ein Designer und Frontend Developer aus dem Vereinigten K√∂nigreich.

        Regeln und Leitplanken festlegen, kein Pixeldesign.

        Bei diesen Werten ist das Design ‚Äì ich sag mal ‚Äì nicht mehr vorhersehbar. 
        Es ist nat√ºrlich deterministisch im technischen Sinne. 
        Allerdings sieht es tats√§chlich auf jedem Device anders aus.

        Keine Ahnung, wie die ZEIT auf dem Galaxy Tablet meiner Mutter mit 127% Schrift-Zoom aussieht.
        Ist mir auch egal. Ich wei√ü aber, dass sie gut aussieht, und lesbar, und stimmig.

        Es geht auf Device-Gr√∂√üen ein (Viewport/Container units), 
        und auf die User Settings (rem), 
        und hat einen guten Rythmus (System, Rundung auf Line Heights).
        </aside>


        <!--div class="slide" data-slide-type="image-only-contain" data-title="Inspirational Image">
            <img src="./images/question_breakpoints.png" alt="" />
        </div-->

<aside>
Und hier kommt der Witz: diese Prinzipien funktionieren nicht nur f√ºr Spacing und Schriftgr√∂√üen.
Sondern auch f√ºr Layouts!
</aside>

        <div class="slide" data-slide-type="code" data-title="CSS Vars: Font Sizes">
            <h2>Breakpoints ü¶£</h2>
<pre><code class="language-css">
.container > * {
    width: 100%;
}

@media (min-width: 600px) {
    width: 45%;
    margin: 5%;
}

@media (min-width: 900px) {
    width: 30%;
    margin: 3%;
}
</code></pre>
        </div>

        <aside>
         Auf kleinen Ger√§ten soll das Layout einspaltig sein. 
         Auf gr√∂√üeren zweispaltig ‚Äì meinetwegen auch 70-30, muss ja nicht die H√§lfte sein.
        Aber wenn es dann noch gr√∂√üer wird, und eigentlich drei Spalten passen w√ºrden ... 
        oder das abh√§ngig davon ist, ob es √ºberhaupt Inhalt f√ºr drei Spalte gibt, 
        da wird es dann komplex. 
        </aside>

        <div class="slide" data-slide-type="code" data-title="CSS Vars: Font Sizes">
            <h2>Grid üêò</h2>
<pre><code class="language-css">
.product-gallery {
    display: grid;
    gap: 2vw;
    grid-template-columns: 1fr;
}
</code></pre>
<pre class="fragment"><code class="language-css">@media (min-width: 600px) {
    grid-template-columns: repeat(2, 1fr);
}
@media (min-width: 900px) {
    grid-template-columns: repeat(3, 1fr);
}
</code></pre>
        </div>

        <aside>
        Deshalb benutzen wir alle CSS Grids. Bei denen wir die Zahl der Columns festlegen k√∂nnen.
        </aside>

        <div class="slide" data-slide-type="image-only-contain" data-title="Inspirational Image">
            <img src="./images/grid_dinoshop.png" alt="" />
        </div>

        <aside>
        Ein Paradebeispiel f√ºr CSS-Grids sind Galerien, oder Produkt-Ansichten in Shops.
        Lasst euch jetzt nicht von den Dinosaurier Chicken Nugget Plushies ablenken.

        Spannend wird es bei der Frage, ob es √ºberhaupt drei Elemente gibt. 
        Oder wenn wenn 4 bis 100 sind, dann muss ich das hier ja √ºber 900 Pixel hinaus 
        bis zu meinem maximalen Breakpoint durchdeklinieren.
        </aside>

        <div class="slide" data-slide-type="image-only" data-title="Inspirational Image">
            <img src="./images/question.png" alt="" />
        </div>

        <aside>
        Es stellt sich wieder die Frage: Was will ich _eigentlich_ erreichen? 
        Ich will dass die Produkte den Platz einnehmen, den sie zur Verf√ºgung haben.
        Sei es der Screen, oder eine sinnvolle Leitplanke von 2000 Pixeln. 
        Oder der Container in der Sidebar.

        Und da drin sollen die Elemente nicht zu gro√ü sein und nicht zu klein.
        Genau das kann ich mit modernem CSS ausdr√ºcken.
        </aside>

        <div class="slide" data-slide-type="code" data-title="CSS Vars: Font Sizes">
            <h2>Auto-Grid ü¶Ñ</h2>
<pre class="fragment"><code class="language-css">
.product-gallery {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
  gap: 2rem;
}

</code></pre>
        </div>

        <div class="slide" data-slide-type="image-only" data-title="Inspirational Image">
            <div class="iframe-device">
                <iframe 
                    src="./iframes/grid-fillfit-8.html" 
                    style="width: 100%; height: 100%; border: none; display: block;">
                </iframe>
            </div>
        </div>

        <div class="slide" data-slide-type="image-only" data-title="Inspirational Image">
            <div class="iframe-device">
                <iframe 
                    src="./iframes/grid-fillfit-3.html" 
                    style="width: 100%; height: 100%; border: none; display: block;">
                </iframe>
            </div>
        </div>


        <aside>
        Wenn es _weniger_ Elemente sind, als Platz zur Verf√ºgung steht, dann kann ich mir aussuchen,
        ob ich den freien Platz ausf√ºlle. Oder ob die Elemente sich so verhalten als g√§be es noch welche.

        Hier _drin_ kann ich dann √ºbrigens die Schrift wieder abh√§ngig von der Containerbreite machen.

        Und sp√§testens hier steigt die alte Denke via Breakpoints sp√§testens aus. 
        Um das beides zu erreichen, m√ºsste ich ein Kreuzprodukt aus Breakpoints und 
        dem Z√§hlen der Elemente per JS oder serverseitig machen.
        </aside>

        <!--div class="slide" data-slide-type="code" data-title="CSS Vars: Font Sizes">
            <h2>Container Query und Container-Inline-Size ü¶Ñ</h2>
<pre><code class="language-css">.grid > div {
    container-type: inline-size;
}
.grid > div > span {
    font-size: 5cqi;
}
</code></pre>
        </div-->

        <aside>
        _Dieses_ Prinzp aus auto-fit und minmax usw kann man sich zunutze machen, wenn man nicht wei√ü, wie viele Inhalte es gibt.
        Zum Beispiel bei den Teasern der ZEIT.
        </aside>

        <div class="slide" data-title="Inspirational Image">
            <div class="r-hstack" style="gap:5vw">
                <img src="./images/grid_zeit-teaser_mobil.png" alt="" style="max-width:50%;max-height:40%;" />
                <img src="./images/grid_zeit-teaser_desktop.png" alt="" style="max-width:60%;max-height:80%;"/>
            </div>
        </div>

        <aside>
        Die manchmal ein Bild haben und manchmal nicht. 
        (Weil es keins gibt, weil die Eilmeldung raus muss bevor es Bildmaterial gibt, oder weil Bildrechte abgelaufen sind.)
        </aside>

        <div class="slide" data-slide-type="code" data-title="Teaser bei ZEIT">
            <h2>Teaser bei ZEIT</h2>
<pre><code class="language-css">
	--teaser-column-auto-width: calc(
		(#{$break-tablet-min} - var(--z-gap) * 2 - var(--z-ds-space-xl)) / 2
	);
	
	display: grid;
	gap: var(--z-ds-space-m) var(--z-ds-space-xl);
	
	grid-template-columns: repeat(
		auto-fit,
		minmax(min(100%, var(--teaser-column-auto-width)), 1fr)
	);

    // see https://kulturbanause.de/blog/css-grid-auto-fill-responsive-layouts-ohne-media-queries/
</code></pre>
        </div>


        <aside>
        Wir setzen uns eine Variable f√ºr die Breite, die ein Teaser-Element idealerweise haben soll.
        Das m√ºssen wir in dem Fall tun, weil andere Teile der Seite noch klassische Breakpoints haben.
        Wir sagen, dass das Element Bildschirm/Containerbreit sein soll (min aus 100 und var), oder nebeneinander laufen (1fr).
        Und auto-fit sorgt daf√ºr, dass der Text auch den Platz des Bildes einnimmt, wenn keines da ist.
        Und der Flie√ütext hat nnoch eine maximale Breite f√ºr die Lesbarkeit.

        Damit reagiert der Teaser auf sein Umfeld ‚Äì und zwar nicht nur auf verschiedene Screens.
        Sondern er ist auch in verschiedenen Layouts einsetzbar. Zweispaltig, dreispaltig, Karusselle, you name it.
        </aside>


        <div class="slide" data-slide-type="title" data-title="Willkommen">
            <h1 style="margin-bottom:1.5em;">CSS Beyond Breakpoints</h1>
            <p class="subtitle">Fazit</p>
        </div>

        <aside>
        Was wir gerade gesehen haben ‚Äì Clamp, font-relative Units, CSS Arithmetik, Auto Grid ‚Äì 
        ist komplexer und schwieriger zu verstehen, als traditionelles CSS mit Breakpoints.
        Man braucht daf√ºr ein gutes Verst√§ndnis der Technologie und des Systems, das hinter dem Design steckt.
        Daf√ºr ist das Ergebnis flexibel ‚Äì was Inhalte und Devices angeht.
        </aside>

        <div class="slide" data-slide-type="title" data-title="Responsive/Intrinsic">
            <h1 style="margin-bottom:1.5em;">CSS Beyond Breakpoints</h1>
            <h2>Responsives Web Design</h2>
            <p class="subtitle">‚Üì</p>
            <h2>Intrinsisches Web Design</h2>
        </div>

        <aside>
        Der Fachbegriff f√ºr die Prinzipien, die wir gerade gesehen haben, ist "Intrinsisches Web Design".
        Statt mit festen Breakpoints basieren die Layouts auf den intrinsischen Eigenschaften des Contents (Gr√∂√üe, Anzahl, Platz) und des User Agents (Device, Schriftgr√∂√üe Settings).
        </aside>

        <div class="slide" data-slide-type="quote" data-title="Andy Bell Quote">
            <blockquote>
                "Be the browser's mentor, <br>not it's micromanager."
            </blockquote>
            <footer>&mdash; Andy Bell</footer>
        </div>

        <aside>
        Es ist nicht der intuitiv leichte Weg ‚Äì aber der, der die St√§rken des Browsers nutzt, 
        Standards einsetzt, und damit einen nachhaltigen Weg geht.
        Diese Ans√§tze √ºberleben jedes Framework, jede neue Major Version von Tailwind.
        Genau die Idee des Lean Web, die ich so sch√§tze.
        Das ist performant und accessible. 
        Es geht auf User Settings ein. Zum Beispiel bez√ºglich der Schriftgr√∂√üe.
        
        Wenn ihr diese Prinzipien anwendet ‚Äì auch Teile davon, k√∂nnt ihr euch am Ende Arbeit ersparen.

        Dann ist eure Website nicht f√ºr alle Nutzenden identisch. 
        Aber sie ist f√ºr alle gut und sch√∂n.
        </aside>

        <div class="slide" data-slide-type="image-only" data-title="Inspirational Image">
            <img src="./images/question.png" alt="" />
        </div>

        <aside>
        Und wenn ich mich frage: welches Web will ich eigentlich haben, und machen? Dann genau so eins.
        </aside>

</div>

    <!-- UI Elements -->
    <div class="slide-counter"></div>
    <div class="progress-bar"></div>
    <!-- div class="fullscreen-hint">Press F11 for Fullscreen (Click to dismiss)</div -->
    <div class="toc-overlay">
        <div class="toc-content">
            <h2>Table of Contents</h2>
            <ul id="toc-list"></ul>
        </div>
    </div>

    <div class="grid-overlay">
        <div id="grid-container"></div>
    </div>

    <script src="script.js"></script>
    <script src="vendor/prism/prism-core.min.js"></script>
    <script src="vendor/prism/prism.min.js"></script>
    <script src="vendor/prism/prism-autoloader.min.js"></script>
    <script src="vendor/prism/prism-config.js"></script>

<!--

        <div class="slide" data-slide-type="title" data-title="Welcome">
            <h1>Welcome to Vibecoding</h1>
            <p class="subtitle">A Basecamp-Inspired Slide Deck</p>
        </div>

        <div class="slide" data-slide-type="headline-text" data-title="Core Idea">
            <h2>Clean & Focused</h2>
            <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Integer nec odio. Praesent libero. Sed cursus ante dapibus diam.</p>
        </div>

        <div class="slide" data-slide-type="bullets" data-title="Key Features">
            <h2>Key Features</h2>
            <ul>
                <li>Single HTML file for portability</li>
                <li>Modern, clean Basecamp-like design</li>
                <li>Keyboard, click, and swipe navigation</li>
                <li>Includes multiple slide layouts</li>
            </ul>
        </div>

        <div class="slide" data-slide-type="image-only" data-title="Inspirational Image">
            <img src="https://picsum.photos/1600/900?grayscale" alt="Grayscale random image">
        </div>

        <div class="slide" data-slide-type="image-text" data-title="Split Layout">
            <div class="image-container">
                <img src="https://picsum.photos/800/600" alt="Random image">
            </div>
            <div class="text-container">
                <h2>Image & Text</h2>
                <p>Praesent libero. Sed cursus ante dapibus diam. Sed nisi. Nulla quis sem at nibh elementum imperdiet. Duis sagittis ipsum.</p>
            </div>
        </div>

        <div class="slide" data-slide-type="code" data-title="Code Example">
            <h2>Code Example</h2>
            <pre><code class="language-js">
function helloWorld() {
  console.log("Hello, from the slide deck!");
}

// Call the function
helloWorld();
            </code></pre>
        </div>

        <div class="slide" data-slide-type="headline-images" data-title="Image Grid">
            <h2>A Gallery of Images</h2>
            <div class="image-grid">
                <img src="./images/font_steps.png" alt="Random image 1" class="fragment">
                <img src="./images/font_multi_steps.png" alt="Random image 2" class="fragment">
                <img src="./images/font_many_steps.png" alt="Random image 3" class="fragment">
                <img src="./images/font_clamp.png" alt="Random image 4" class="fragment">
            </div>
        </div>

        <div class="slide" data-slide-type="code-explanation" data-title="Code Explanation: clamp()">
            <h2>Dissecting CSS `clamp()`</h2>
            <pre><code class="no-highlight">font-size: clamp(<span data-highlight-id="1">1.25rem</span>, <span data-highlight-id="2">2vw + 1rem</span>, <span data-highlight-id="3">2.5rem</span>);</code></pre>
            <div class="explanation-container">
                <div class="fragment" data-explains="1">
                    <p><strong>Minimum Value:</strong> This is the smallest the font size will ever be. It acts as the lower bound.</p>
                </div>
                <div class="fragment" data-explains="2">
                    <p><strong>Preferred Value:</strong> This is the ideal, flexible value that scales with the viewport width.</p>
                </div>
                <div class="fragment" data-explains="3">
                    <p><strong>Maximum Value:</strong> This is the largest the font size can get, acting as the upper bound.</p>
                </div>
            </div>
        </div>

        <div class="slide" data-slide-type="quote" data-title="A Wise Quote">
            <blockquote>
                "The most important thing in communication is hearing what isn't said."
            </blockquote>
            <footer>&mdash; Peter Drucker</footer>
        </div>
    
-->

</body>
</html>
