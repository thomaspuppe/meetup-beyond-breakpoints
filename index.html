<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vibecoding Slide Deck</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css">
    <link rel="stylesheet" href="style.css">
</head>
<body>

    <!-- Meta: Runde story bleibt h√§ngen. Detail-Grfriemel nicht. -->
    <!-- TODO: Was war Nicos Idee f√ºr responsive Web Design? Catchy Phrases einbauen. -->


    <div class="slide-container">
        <!-- Slide 1: Title -->
        <div class="slide" data-slide-type="title" data-title="Welcome">
            <h1>Welcome to Vibecoding</h1>
            <p class="subtitle">A Basecamp-Inspired Slide Deck</p>
        </div>

        <!-- Slide 2: Headline + Text -->
        <div class="slide" data-slide-type="headline-text" data-title="Core Idea">
            <h2>Clean & Focused</h2>
            <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Integer nec odio. Praesent libero. Sed cursus ante dapibus diam.</p>
        </div>

        <!-- Slide 3: Bullet Points -->
        <div class="slide" data-slide-type="bullets" data-title="Key Features">
            <h2>Key Features</h2>
            <ul>
                <li>Single HTML file for portability</li>
                <li>Modern, clean Basecamp-like design</li>
                <li>Keyboard, click, and swipe navigation</li>
                <li>Includes multiple slide layouts</li>
            </ul>
        </div>

        <!-- Slide 4: Image Only -->
        <div class="slide" data-slide-type="image-only" data-title="Inspirational Image">
            <img src="https://picsum.photos/1600/900?grayscale" alt="Grayscale random image">
        </div>

        <!-- Slide 5: Image + Text -->
        <div class="slide" data-slide-type="image-text" data-title="Split Layout">
            <div class="image-container">
                <img src="https://picsum.photos/800/600" alt="Random image">
            </div>
            <div class="text-container">
                <h2>Image & Text</h2>
                <p>Praesent libero. Sed cursus ante dapibus diam. Sed nisi. Nulla quis sem at nibh elementum imperdiet. Duis sagittis ipsum.</p>
            </div>
        </div>

        <!-- Slide 6: Code Example -->
        <div class="slide" data-slide-type="code" data-title="Code Example">
            <h2>Code Example</h2>
            <pre><code class="language-js">
function helloWorld() {
  console.log("Hello, from the slide deck!");
}

// Call the function
helloWorld();
            </code></pre>
        </div>

        <!-- Slide 7: Headline + 4 Images with Fragments -->
        <div class="slide" data-slide-type="headline-images" data-title="Image Grid">
            <h2>A Gallery of Images</h2>
            <div class="image-grid">
                <img src="./images/font_steps.png" alt="Random image 1" class="fragment">
                <img src="./images/font_multi_steps.png" alt="Random image 2" class="fragment">
                <img src="./images/font_many_steps.png" alt="Random image 3" class="fragment">
                <img src="./images/font_clamp.png" alt="Random image 4" class="fragment">
            </div>
        </div>

        <!-- Slide 8: Code Explanation -->
        <div class="slide" data-slide-type="code-explanation" data-title="Code Explanation: clamp()">
            <h2>Dissecting CSS `clamp()`</h2>
            <pre><code class="no-highlight">font-size: clamp(<span data-highlight-id="1">1.25rem</span>, <span data-highlight-id="2">2vw + 1rem</span>, <span data-highlight-id="3">2.5rem</span>);</code></pre>
            <div class="explanation-container">
                <div class="fragment" data-explains="1">
                    <p><strong>Minimum Value:</strong> This is the smallest the font size will ever be. It acts as the lower bound.</p>
                </div>
                <div class="fragment" data-explains="2">
                    <p><strong>Preferred Value:</strong> This is the ideal, flexible value that scales with the viewport width.</p>
                </div>
                <div class="fragment" data-explains="3">
                    <p><strong>Maximum Value:</strong> This is the largest the font size can get, acting as the upper bound.</p>
                </div>
            </div>
        </div>

        <!-- Slide 9: Quote -->
        <div class="slide" data-slide-type="quote" data-title="A Wise Quote">
            <blockquote>
                "The most important thing in communication is hearing what isn't said."
            </blockquote>
            <footer>&mdash; Peter Drucker</footer>
        </div>


        <!-- ===============================================================
         +++ +++ +++ +++ Real Content Starts Here. +++ +++ +++ +++ +++
         =============================================================== -->

        <div class="slide" data-slide-type="title" data-title="Willkommen">
            <h1>CSS Beyond Breakpoints</h1>
            <p class="subtitle">Design und Layout ohne Breakpoints, daf√ºr mit modernem CSS</p>
            <p style="display:flex; gap:1ch; font-style:italic;align-items: center;justify-content: center;">
                <img height="50" width="50" style="margin-block: 0; border-radius: 50%;" src="https://ca.slack-edge.com/T025QU23Y-U2EQQ36V8-g11ce98f30b2-192" alt="">
                Thomas Puppe
            </p>
        </div>
<!-- 
Guten Abend. Ich m√∂chte mit euch √ºber CSS sprechen. (Also erstmal zu euch, und dann sehen wir weiter.)
Mein Name ist Thomas Puppe. Ich bin Senior Frontend Developer bei der ZEIT.
-->

        <!-- TODO: Layout Typ wie im anderen nachbauen-->
        <div class="slide" data-slide-type="title" data-title="Willkommen 2">
            <h1>Hi, ich bin Thomas üëã</h1>
                <img data-src="images/intro/toy-face.png" width="300px"/>
                <div>								
                    <p>Senior Frontend Developer <br>bei ZEIT Online</p>
                    <em>#a11y, #leanweb, #webperf</em>
                </div>
        </div>

        <!--
        Ich baue seit einem Vierteljahrhundert Websites. Und meine Steckenpferde sind Accessibility, Performance, und etwas das man "LeanWeb" nennt.
        Die Idee, dass Websites einfach und klein und leicht zu warten sein sollten, 
        Damit passe ich ganz gut zu ZEIT. (Formerly ZEIT Online.)
        -->

        <!-- TODO: Layout Typ wie im anderen nachbauen, Screenshots rein. -->
        <div class="slide" data-slide-type="title" data-title="Willkommen 3">
            <h1>zeit.de</h1>
        </div>

        <!--
        Wir legen auch wert auf Standardkonformit√§t, Accessibility, Performance. 
        Und auf Wartbarkeit, weil es ist eine gro√üe Codebasis, die wir da seit 10 Jahren betreuen.
        Dazu geh√∂rt: Wenig Frameworks, Viel Vanilla.
        Eher konservativ bzgl Browser-Support; aber wenn etwas unterst√ºtzt wird, dann nutzen wir die verf√ºgbare Technologie im Sinne des Lean Web.
        Also dass man sich lieber auf den Browser verl√§sst, und dessen F√§higkeiten nutzt, anstatt das Rad selber neu zu erfinden.
        -->

        <div class="slide" data-slide-type="bullets" data-title="Inhalt">
            <h2>CSS Beyond Breakpoints</h2>
            <ul>
                <li>CSS Vars (mit Breakpoints)
                    <ul>
                        <li>Farben, Spacing, Schriften</li>
                    </ul>
                </li>
                <li>Min/Max und Clamping</li>
                <li>Space Clamping</li>
                <li>Includes multiple slide layouts</li>
                <!-- TODO -->
            </ul>
        </div>

        <!-- 0910
        Und davon handelt mein heutiger Talk. CSS beyond Breakpoints.
        Wie √ºberwinden wir das, was ich vor 15 Jahren gelernt habe im Zuge von Responsive Web Design, Mobile First, viel mit Breakpoints.
        Und welche moderneren Sachen gibt es da?
        Als erstes spreche ich doch noch √ºber Breakpoints, quasi als Hinf√ºhrung. Und dann ... TODO
        -->

        <!-- --------------------------------------------------------------
         Section: CSS Vars
         -------------------------------------------------------------- -->

        <!-- TODO: data-title nur nutzen, wenn keine h1/h2 verf√ºgbar ist. -->
        <div class="slide" data-slide-type="code" data-title="CSS Vars: Colors">
            <p>CSS Vars: Colors</p>
            <h2>Dark Mode fr√ºher ü¶£</h2>
<pre class="fragment"><code class="language-css">
	body {
		background: white;
		color: black;
	}
	@media (prefers-color-scheme: dark) {
		.body {
			background: black;
			color: white;
		}
	}
</code></pre>
        </div>
        <div class="slide" data-slide-type="code" data-title="CSS Vars: Colors">
            <p>CSS Vars: Colors</p>
            <h2>Dark Mode mit CSS Vars üêò</h2>
<pre><code class="language-css">
:root {
    --z-ds-color-text-100: #252525; // Primary Information
    --z-ds-color-text-70: #444; // Secondary Information
    --z-ds-color-text-40: #999; // Low Prio
    --z-ds-color-background-0: #fff; // Primary
}
:root {
    @media (prefers-color-scheme: dark) {
        --z-ds-color-text-100: #fff;
        --z-ds-color-text-70: #bababa;
        --z-ds-color-text-40: #8b8b8b;
        --z-ds-color-background-0: #121212;
    }
}
body {
    background: var(--z-ds-color-background-0);
    color: var(--z-ds-color-text-100);
}
</code></pre>
        </div>
        <div class="slide" data-slide-type="code" data-title="CSS Vars: Colors">
            <p>CSS Vars: Colors</p>
            <h2>Dark Mode mit light-dark() ü¶Ñ</h2>
<!-- TODO: pr√ºfen ob das wirklich geht -->
<pre><code class="language-css">
:root {
    color-scheme: light dark;
    --z-ds-color-text-100: light-dark(#252525, #fff); // Primary Information
    --z-ds-color-text-70: light-dark(#444, #bababa); // Secondary Information
    --z-ds-color-text-40: light-dark(#999, #8b8b8b); // Low Prio
    --z-ds-color-background-0: light-dark(#fff, #121212); // Primary
}
body {
    background: var(--z-ds-color-background-0);
    color: var(--z-ds-color-text-100);
}
</code></pre>
        </div>

        <!--
        Was sich durch beide Beispiele zieht, sind die CSS Variablen.
        F√ºr ein konsistentes Design und eine wartbare Seite sind die gold wert!
        Ich will auf keinen Fall an irgendwelchen Texten, Teasern, Footerbars, was-auch-immer mit Farbwerten hantieren, sondern mit Variablen. 
        Die sind an einer Stelle definiert ‚Äì damit habe ich auch gleich mein Inventar in Form von Design Tokens ‚Äì und werden dann im Projekt nur noch genutzt.
        -->

        <div class="slide" data-slide-type="code" data-title="CSS Vars: Colors">
            <p>CSS Vars: Colors</p>
            <h2>Wartbarkeit ü¶Ñ</h2>
<!-- TODO: pr√ºfen ob das wirklich geht / TODO: das weglassen?? !!--> 
<pre><code class="language-css">
:root {
    color-scheme: light dark;
    --z-ds-color-text-100: light-dark(#252525, #fff); // Primary Information
}
body {
    color: var(--z-ds-color-text-100);
}

.teaser--verlagsangebot {
    --z-ds-color-text-100: light-dark(#353535, #eee);
}
</code></pre>
        </div>


        <!--
        So wie ich Farben im CSS als globale Design Tokens definiere, und dann nur noch benutze, so gehe ich auch mit Schriftgr√∂√üen um.
        -->

        <div class="slide" data-slide-type="code" data-title="CSS Vars: Font Sizes">
            <h2>CSS Vars: Font Sizes</h2>
<pre><code class="language-css">
--zeit-fontsize-s: 1rem;
--zeit-fontsize-m: 1.25rem;
--zeit-fontsize-l: 1.5rem;

// TODO: @media (min-width: 600px)
@include respond-min($break-tablet-min) {
    --zeit-fontsize-m: 1.5rem;
    --zeit-fontsize-l: 2rem;
}
</code></pre>
<pre class="fragment"><code class="language-css">
.zon-teaser h2 {
    font-size: var(--zeit-fontsize-m);
}

.zon-teaser--large h2 {
    font-size: var(--zeit-fontsize-l);
}
</code></pre>
        </div>


<!--
Ich hab schonmal den Teil √ºbersprungen, der vorhin als schlechtes Beispiel galt: 
Auf gar keinen Fall will ich innerhalb meines Teaser-Designs mit Breakpoints hantieren.
Ich habe ein Set an Schriftgr√∂√üen, die sind untereinander austariert, und mit denen arbeite ich.
Wenn jetzt ein Design kommt, das eine andere Kombination will (mobil die S und auf Desktop die M), dann hab ich ... TODO
-->

        <div class="slide" data-slide-type="image-only" data-title="Inspirational Image">
            <!-- TODO: Iframe so ein bisschen Device-like nen Rahmen geben.-->
            <div style="resize: both; overflow: auto; width: 90%px; height: 90%; border: 1px solid #ccc; display: inline-block;">
                <iframe 
                    src="./iframes/font-breakpoint.html" 
                    style="width: 100%; height: 100%; border: none; display: block;">
                </iframe>
            </div>
        </div>

<!-- 0915
Das Ergebnis sehen wir hier. Ganz klassisch. Kleine Schrift, und ab einem Breakpoint wird sie gr√∂√üer.
Das ist ganz cool. Aber: irgendwie unbefriedigend an manchen Stellen. 
Kurz vor dem Breakpoint ist die Schrift etwas verloren. Und kurz danach etwas zu gro√ü vielleicht.
-->

        <div class="slide" data-slide-type="headline-images" data-title="Image Grid">
            <h2>Breakpoints f√ºr Font Sizes</h2>
            <div class="image-grid">
                <img src="./images/font_steps.png" alt="Random image 1" class="fragment">
                <img src="./images/font_multi_steps.png" alt="Random image 2" class="fragment">
                <img src="./images/font_many_steps.png" alt="Random image 3" class="fragment">
            </div>
        </div>
<!--
Jetzt k√∂nnte ich nat√ºrlich in kleineren Schritten vorgehen.
Das wird nat√ºrlich unhandlich. Aber es f√ºhrt uns zu einer spannenden Frage:
TODO: Frage √ºber die Grafik legen!
-->

        <div class="slide" data-slide-type="image-only" data-title="Inspirational Image">
            <img src="./images/question.png" alt="Grayscale random image">
        </div>

<!--
Aber mein Kollege Moritz hat so ein gefl√ºgeltes Wort gepr√§gt: Die Frage "Was will ich _eigentlich_ erreichen?"
Ich will nicht bei 767 Pixeln Schriftgr√∂√üe 20, und bei 768 Pixel Schriftgr√∂√üe 30. 
Aber genau das machen wir bei responsivem Web Design mittels Media Queries.
Ich will, dass sich die Schrift dem Bildschirm anpasst. Proportional. Also quasi sowas:
-->


        <div class="slide" data-slide-type="headline-images" data-title="Image Grid">
            <h2>Breakpoints f√ºr Font Sizes</h2>
            <div class="image-grid">
                <img src="./images/font_steps.png" alt="Random image 1">
                <img src="./images/font_multi_steps.png" alt="Random image 2">
                <img src="./images/font_many_steps.png" alt="Random image 3">
                <img src="./images/font_clamp.png" alt="Random image 4">
            </div>
        </div>

<!-- 
Und genau das erreichen wir mit bildschirm-relationalen Einheiten, und mit clamp.
TODO; Browser Setting Screenshot
-->

        <div class="slide" data-slide-type="code-explanation" data-title="Code Explanation: clamp()">
            <h2>CSS `clamp()` ü¶Ñ</h2>
            <pre><code class="no-highlight">font-size: clamp(<span data-highlight-id="1">1.25rem</span>, <span data-highlight-id="2">2vw + 1rem</span>, <span data-highlight-id="3">2.5rem</span>);</code></pre>
            <div class="explanation-container">
                <div class="fragment" data-explains="1">
                    <p><strong>Minimum Value:</strong> This is the smallest the font size will ever be. It acts as the lower bound.</p>
                </div>
                <div class="fragment" data-explains="2">
                    <p><strong>Preferred Value:</strong> This is the ideal, flexible value that scales with the viewport width.</p>
                </div>
                <div class="fragment" data-explains="3">
                    <p><strong>Maximum Value:</strong> This is the largest the font size can get, acting as the upper bound.</p>
                </div>
            </div>
        </div>


        <div class="slide" data-slide-type="code" data-title="CSS Vars: Font Sizes">
            <p>CSS Vars: Font Sizes</p>
            <h2>Font Sizes mit `clamp()` ü¶Ñ</h2>
<pre><code class="language-css">
    --zeit-fontsize-2: clamp(1rem, 1.2vw + 0.8rem, 2rem);
    --zeit-fontsize-m: clamp(1.25rem, 2vw + 1rem, 5rem);
    --zeit-fontsize-xl: clamp(2rem, 4vw + 1rem, 6rem);
    
    p {
        font-size: var(--zeit-fontsize-m);
    }
    h1 {
        font-size: var(--zeit-fontsize-xl);
    }
</code></pre>
</div>

        <div class="slide" data-slide-type="image-only" data-title="Inspirational Image">
            <div style="resize: both; overflow: auto; width: 90%px; height: 90%; border: 1px solid #ccc; display: inline-block;">
                <iframe 
                    src="./iframes/font-clamp.html" 
                    style="width: 100%; height: 100%; border: none; display: block;">
                </iframe>
            </div>
        </div>

<!-- TODO: Utopia Tool verlinken-->

        <div class="slide" data-slide-type="code" data-title="CSS Vars: Spacing">
            <p>CSS Vars: Spacing</p>
            <h2>Spacing mit `clamp()` ü¶Ñ</h2>

            <pre><code class="language-css">
--zeit-space-s: 0.5rem;
--zeit-space-l: clamp(1rem, 1.2vw + 0.8rem, 2rem);;
--zeit-space-xl: clamp(2rem, 4vw + 1rem, 6rem);

h1 {
    margin-block: var(--zeit-space-xl);
}
h2 {
    margin-block: var(--zeit-space-l);
}
p {
    margin-block: var(--zeit-space-s);
}
</code></pre>
</div>

<!-- TODO: Utopia Tool verlinken. Hier, oder woanders?? Als Zwischenfolie vielleicht?? -->

<!--
Bei Paragraphs setzen wir das kleinere Spacing ein, bei √úberschriften das gr√∂√üere.
Jetzt kann man sich fragen ... 
-->

        <div class="slide" data-slide-type="image-only" data-title="Inspirational Image">
            <img src="./images/question.png" alt="Grayscale random image" />
        </div>

<!--
Was will ich eigentlich?
Ich will nicht 20px unter Abs√§tzen, und 30 Pixel unter √úberschriften. Sondern ich will, dass go√üer Text mehr Spacing hat als kleiner Text.
Daf√ºr gibt es schriftrelatve Einheiten in CSS! 
-->

        <div class="slide" data-slide-type="code" data-title="CSS Vars: Spacing">
<h2>Spacing mit relativen Einheiten ü¶Ñ</h2>
<pre class="fragment"><code class="language-css">h1, h2 {
    margin-block: 2em;
    margin-block: 2lh;
}</code></pre>

        <!-- Viewport Inline(!), runde auf halbe Zeilenh√∂hen (lokal) -->
    <pre class="fragment"><code class="language-css">h1, h2 {
    margin-block: min(1lh, 2vi);
    margin-block: round(up, 2vb, 0.5lh);
}</code></pre>

<pre class="fragment"><code class="language-css">@supports (font-size: 1cqi) {
	font-size: clamp(rem(82px), 8.2cqi, rem(164px));
}</code></pre>

<pre class="fragment"><code class="language-css">p:not([class])  {
    max-width: min(70ch, 100% - 4rem);
}
</code></pre>

</div>

        <!-- 0922
        Min() und Round() sind zwei weitere arithmetische Funktionen in CSS.
        vi und round auf lh sind typische relative Einheiten.
        ch f√ºr character, cap f√ºr Gr√∂√üe des Capital Letters
        .Oder COntainer Queries. Mach Zeug abh√§ngig von der Gr√∂√üe des Containers.

        Sprecht mal mit euren Designer:innen √ºber solche Regeln. Wenn ihr ganz viel Gl√ºck habt, 
        haben die sich vielleicht was dabei gedacht, als sie die Werte festgelegt haben. 
        Sowas wie ein System. F√ºrs Design.
        Und es k√∂nnte sein, dass die Grundlage f√ºr die Pixelwerte solche √úberlegungen sind.
        Nur dass im Figma eben die Snapshots landen von zwei, drei festen Gr√∂√üen.
        
        Und wir als Entwickler:innen nehmen das als feste Gr√∂√üen pro Breakpoint.
        Weil uns die gemeinsame Sprache fehlt f√ºr die Welt zwischen den Designs.
        -->

        <div class="slide" data-slide-type="quote" data-title="Andy Bell Quote">
            <blockquote>
                "Be the browser's mentor, <br>not it's micromanager."
            </blockquote>
            <footer>&mdash; Andy Bell</footer>
        </div>

        <!-- 
        TODO: Wer ist / was macht Andy Bell?
        Regeln und Leitplanken festlegen, kein Pixeldesign. 
        Bei diesen Werten ist das Design ‚Äì ich sag mal ‚Äì nicht mehr vorhersehbar. 
        Es ist nat√ºrlich deterministisch im technischen Sinne. Allerdings sieht es tats√§chlich 
        auf jedem Device anders aus. ABER: es sieht auf jedem Device gut aus, und stimmig.
        Es passt zum Device, und es passt zum Umfeld, ergibt einen ruhigen Rhythmus.
        -->


        <div class="slide" data-slide-type="image-only-contain" data-title="Inspirational Image">
            <img src="./images/question_breakpoints.png" alt="Grayscale random image" />
        </div>

<!-- 0925
Und hier kommt der Witz: diese Prinzipien funktionieren nicht nur f√ºr Spacing und Schriftgr√∂√üen.
Sondern auch f√ºr Layouts!
-->

        <div class="slide" data-slide-type="code" data-title="CSS Vars: Font Sizes">
            <h2>Breakpoints ü¶£</h2>
<pre><code class="language-css">
.container > * {
    width: 100%;
}
</code></pre>
<pre class="fragment"><code class="language-css">@media (min-width: 600px) {
    width: 45%;
    margin: 5%;
}
</code></pre>
<pre class="fragment"><code class="language-css">@media (min-width: 900px) {
    width: 30%;
    margin: 3%;
}
</code></pre>
        </div>

        <!--
         Auf kleinen Ger√§ten soll das Layout einspaltig sein. 
         Auf gr√∂√üeren zweispaltig ‚Äì meinetwegen auch 70-30, muss ja nicht die H√§lfte sein.
        Aber wenn es dann noch gr√∂√üer wird, und eigentlich drei Spalten passen w√ºrden ... 
        oder das abh√§ngig davon ist, ob es √ºberhaupt Inhalt f√ºr drei Spalte gibt, 
        da wird es dann komplex. 
        -->

        <div class="slide" data-slide-type="image-only-contain" data-title="Inspirational Image">
            <img src="./images/grid_dinoshop.png" alt="Grayscale random image" />
        </div>

        <!--
        Nehmen wir einen Shop. Das Paradebeispiel f√ºr CSS-Grids.
        Lasst euch jetzt nicht von den Dinosaurier Chicken Nugget Plushies ablenken.
        -->

        <div class="slide" data-slide-type="code" data-title="CSS Vars: Font Sizes">
            <h2>Grid üêò</h2>
<pre><code class="language-css">
.product-gallery {
    display: grid;
    gap: 2vw;
    grid-template-columns: 1fr;
}
</code></pre>
<pre class="fragment"><code class="language-css">@media (min-width: 600px) {
    grid-template-columns: repeat(2, 1fr);
}
@media (min-width: 900px) {
    grid-template-columns: repeat(3, 1fr);
}
</code></pre>
        </div>

        <!--
        Spannend wird es bei der Frage, ob es √ºberhaupt drei Elemente gibt. 
        Oder wenn wenn 4 bis 100 sind, dann muss ich das hier ja √ºber 900 Pixel hinaus 
        bis zu meinem maximalen Breakpoint durchdeklinieren.
         -->

        <div class="slide" data-slide-type="image-only" data-title="Inspirational Image">
            <img src="./images/question.png" alt="Grayscale random image" />
        </div>

        <!--
        Was will ich _eigentlich_? Ich will dass die Produkte den Platz einnehmen, den sie haben.
        Sei es der Screen, oder eine sinnvolle Leitplanke von 2000 Pixeln.
        Und da drin sollen die Elemente nicht zu gro√ü sein und nicht zu klein.
        Genau das kann ich mit modernem CSS ausdr√ºcken.
         -->

        <div class="slide" data-slide-type="code" data-title="CSS Vars: Font Sizes">
            <h2>Auto-Grid ü¶Ñ</h2>
<pre class="fragment"><code class="language-css">
.product-gallery {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
  gap: 1rem;
}

</code></pre>
        </div>

        <div class="slide" data-slide-type="image-only" data-title="Inspirational Image">
            <div style="resize: both; overflow: auto; width: 90%px; height: 90%; border: 1px solid #ccc; display: inline-block;">
                <iframe 
                    src="./iframes/grid-fillfit-8.html" 
                    style="width: 100%; height: 100%; border: none; display: block;">
                </iframe>
            </div>
        </div>

        <div class="slide" data-slide-type="image-only" data-title="Inspirational Image">
            <div style="resize: both; overflow: auto; width: 90%px; height: 90%; border: 1px solid #ccc; display: inline-block;">
                <iframe 
                    src="./iframes/grid-fillfit-3.html" 
                    style="width: 100%; height: 100%; border: none; display: block;">
                </iframe>
            </div>
        </div>

        <div class="slide" data-slide-type="code" data-title="CSS Vars: Font Sizes">
            <h2>Container Query und Container-Inline-Size ü¶Ñ</h2>
<pre><code class="language-css">.grid > div {
    container-type: inline-size;
}
.grid > div > span {
    font-size: 5cqi;
}
</code></pre>
        </div>

         <!-- 
        Hier drin kann ich √ºbrigens die Schrift wieder abh√§ngig von der Containerbreite machen.
        Und _dieses_ prinzp kann man sich zunutze machen, wenn man nicht wei√ü, wie viele Inhalte es gibt.
        Zum Beispiel bei den Teasern der ZEIT.
        -->

        <div class="slide" data-title="Inspirational Image">
            <div class="r-hstack">
                <img src="./images/grid_zeit-teaser_mobil.png" alt="Grayscale random image" style="max-width:50%;max-height:40%;" />
                <img src="./images/grid_zeit-teaser_desktop.png" alt="Grayscale random image" style="max-width:60%;max-height:80%;"/>
            </div>
        </div>

        <!--
        Die manchmal ein Bild haben und manchmal nicht. 
        (Weil es keins gibt, weil die Eilmeldung raus muss bevor es Bildmaterial gibt, oder weil Bildrechte abgelaufen sind.)
         -->


                <!-- Beispiel mit unserem Teaser. -->
        <div class="slide" data-slide-type="code" data-title="Teaser bei ZEIT">
            <h2>Teaser bei ZEIT</h2>
<pre><code class="language-css">
	--teaser-column-auto-width: calc(
		(#{$break-tablet-min} - var(--z-gap) * 2 - var(--z-ds-space-xl)) / 2
	);
	
	display: grid;
	gap: var(--z-ds-space-m) var(--z-ds-space-xl);
	
	grid-template-columns: repeat(
		auto-fit,
		minmax(min(100%, var(--teaser-column-auto-width)), 1fr)
	);
    // see https://kulturbanause.de/blog/css-grid-auto-fill-responsive-layouts-ohne-media-queries/
</code></pre>
        </div>


<!-- 0933, ZEIT OVER!!
        TODO: unser CSS beschreiben -->


        <div class="slide" data-slide-type="title" data-title="Willkommen">
            <h1 style="margin-bottom:1.5em;">CSS Beyond Breakpoints</h1>
            <p class="subtitle">Fazit</p>
        </div>

        <!--
        Was wir gerade gesehen haben, ist komplexer und schwieriger zu verstehen, als traditionelles CSS mit Breakpoints.
        Man braucht daf√ºr ein tiefes Verst√§ndnis der Technologie und des Systems, das hinter dem Design steckt.
        Daf√ºr ist das Ergebnis flexibel ‚Äì was Inhalte und Devices angeht.
         -->


        <div class="slide" data-slide-type="title" data-title="Responsive/Intrinsic">
            <h1 style="margin-bottom:1.5em;">CSS Beyond Breakpoints</h1>
            <h2>Responsives Web Design</h2>
            <p class="subtitle">‚Üì</p>
            <h2>Intrinsisches Web Design</h2>
        </div>

        <!-- Responsive Web Design: Begriff von Etah Marcotte gepr√§gt. 
         In einem Artikel auf A List Apart im Jahr 2010. Ein Jahr sp√§ter wurde ein Buch draus.
         Man musste die steigende Zahl von mobilen Ger√§ten bedienen. 
         Anfangs gab es noch m.zeit.de , oder mobil.spiegel.de .
         Aber sp√§ter mit mehr Devices, mehr Verbreitung, und sp√§testens mit Tablets,
         habe sich Breakpoints durchgesetzt.
         TODO: Sch√∂ne griffige Erkl√§rung, und Hinweis um das zu googlen.
        -->


        <div class="slide" data-slide-type="quote" data-title="Andy Bell Quote">
            <blockquote>
                "Be the browser's mentor, <br>not it's micromanager."
            </blockquote>
            <footer>&mdash; Andy Bell</footer>
        </div>

        <!--
        Es ist nicht der intuitiv leichte Weg ‚Äì aber der, der die St√§rken des Browsers nutzt, 
        Standards einsetzt, und damit einen nachhaltigen Weg geht. 
        Genau die Idee des Lean Web, die ich so sch√§tze.
        Diese Ans√§tze √ºberleben jedes Framework, jede neue Major Version von Tailwind.
        Das ist performant und accessible. 
        Es geht auf User Settings ein. Zum Beispiel bez√ºglich der Schriftgr√∂√üe.
        Damit ist das Web nicht f√ºr alle identisch. Aber es ist f√ºr alle gut und sch√∂n.
         -->

        <div class="slide" data-slide-type="image-only" data-title="Inspirational Image">
            <img src="./images/question.png" alt="Grayscale random image" />
        </div>

        <!-- 
        Und wenn ihr mich fragt: das ist das Web, das ich eigentlich will.
        -->




        <div class="slide" data-slide-type="image-only" data-title="Inspirational Image">
            <div style="resize: both; overflow: auto; width: 90%px; height: 90%; border: 1px solid #ccc; display: inline-block;">
                <iframe 
                    src="./iframes/color-clamp.html" 
                    style="width: 100%; height: 100%; border: none; display: block;">
                </iframe>
            </div>
        </div>

        <!-- TODO: √úbergang von "Spacing" zu "Layout" -->

        <!-- Regeln und Leitplanken festlegen, kein Pixeldesign. -->

        <div class="slide" data-slide-type="title" data-title="Responsive/Intrinsic">
            <h2>Intrinsisches Web Design</h2>
            <p>Layouts, die auf den intrinsischen Eigenschaften des Contents basieren (Gr√∂√üe, Anzahl, Platz) statt auf festen Breakpoints.</p>

            <!-- 
            Intrinsisches Design bedeutet: Der Browser entscheidet basierend auf dem verf√ºgbaren Platz ‚Äì nicht wir mit festen Breakpoints. 

            Extrinsisch (alt): "Bei 768px mache 2 Spalten, bei 1024px mache 3 Spalten"
            Intrinsisch (neu): "Mache so viele Spalten wie reinpassen, mindestens 300px breit.
            -->
        </div>


        <!-- --------------------------------------------------------------
         Section: Layout mit Grid und minmax
         -------------------------------------------------------------- -->

         <!-- Modernes Layout mit Grid. Super flexibel und gut zu handhaben. 
            Intrinsisches Design ist schon angelegt, und f√ºhlt sich nat√ºrlicher an.
            Was man traditionell machen w√ºrde: je nach Breakpoint mehr oder weniger Cols.
            (TODO: finden ob das nicht Tailwind oder Bootstrap tats√§chlich so macht ??)
            Mag auch sinnvoll sein f√ºr bestimmte Anwendungsf√§lle (ich kenne Screen und Anzahl der Elemente).
            Aber f√ºr unbekannte Inhalte und Devices spielt es voll seine St√§rken aus.
         -->





</div>

    <!-- UI Elements -->
    <div class="slide-counter"></div>
    <div class="progress-bar"></div>
    <!-- div class="fullscreen-hint">Press F11 for Fullscreen (Click to dismiss)</div -->
    <div class="toc-overlay">
        <div class="toc-content">
            <h2>Table of Contents</h2>
            <ul id="toc-list"></ul>
        </div>
    </div>

    <div class="grid-overlay">
        <div id="grid-container"></div>
    </div>

    <script src="script.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
</body>
</html>
